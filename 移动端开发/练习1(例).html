<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        *{
            margin: 0;
            padding: 0;
        }
    .container{
        max-width: 960px;
        margin: 0 auto
    }
    header,nav,footer{
        width: 100%;
        height:100px;
        background-color: #999999;
        text-align: center;
        line-height: 100px;
        margin-bottom: 10px;
    }
    .img-bar{
        width: 100%;
        background: url("./1.jpg") no-repeat center/cover;
        padding-bottom: 62.6%;
    }
    .clearfix::after{
        content: "";
        display: block;
        clear: both;
    }
    .info-bar article{
        width: 65%;
        background-color: pink;
        float: left;
        height: 300px;
    }
    .info-bar aside{
        width: 30%;
        background-color: yellowgreen;
        float: right;
        height: 300px;
    }
    .info-bar{
        margin: 10px 0;
    }
    .info-bar p{
        position: absolute;
        top:50%;
        transform: translateY(-50%);
        text-align: center;
    }
    
    </style>
</head>
<body>
<div class="container">
    <header>页头</header>
    <nav>导航</nav>
    <div class="img-bar"></div>
    <div class="info-bar clearfix">
        <article ><p>未定义的属性不会被复制。然而，从对象原型的继承属性将被复制。如果属性（Properties）是一个通过构造函数new MyCustomObject(args)定义的，或JavaScript中内置类型，如Date 或 RegExp，是不会重新创建的，并且将被当作普通的对象出在返回的对象或数组中。
                若设置了 deep 参数，对象和数组也会被合并进来，但是对象包裹的原始类型，比如String, Boolean, 和 Number是不会被合并进来的。</p></article>
        <aside><p>在默认情况下，通过$.extend()合并操作不是递归的;如果第一个对象的属性本身是一个对象或数组，那么它将完全用第二个对象相同的key重写一个属性。这些值不会被合并。可以通过检查下面例子中 banana 的值，就可以了解这一点。然而，如果将 true 作为该函数的第一个参数，那么会在对象上进行递归的合并。</p></aside>
    <footer>页脚</footer>
    </div>
</div>
</body>
</html>